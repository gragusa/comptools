<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.17">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Computational Tools for Macroeconometrics 2024/2025 - Giuseppe Ragusa - Sapienza">

<title>Computational Tools for Macroeconometrics</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href=".//files/icon-512.png" rel="icon" type="image/png">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-2577ed9d2f9b020f727002863c1eb492.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-5e28daa043729a5b19c338f8d2db2612.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Computational Tools for Macroeconometrics</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="./comptools_ass1.html"> 
<span class="menu-text">Assignment 1</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./comptools_ass2.html"> 
<span class="menu-text">Assignment 2</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./comptools_ass3.html" aria-current="page"> 
<span class="menu-text">Assignment 3</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#monte-carlo-experiments" id="toc-monte-carlo-experiments" class="nav-link active" data-scroll-target="#monte-carlo-experiments">Monte Carlo experiments</a></li>
  <li><a href="#bootstrap" id="toc-bootstrap" class="nav-link" data-scroll-target="#bootstrap">Bootstrap</a></li>
  <li><a href="#linear-model-with-dependent-data" id="toc-linear-model-with-dependent-data" class="nav-link" data-scroll-target="#linear-model-with-dependent-data">Linear model with dependent data</a>
  <ul class="collapse">
  <li><a href="#steps-for-moving-block-bootstrap-mbb" id="toc-steps-for-moving-block-bootstrap-mbb" class="nav-link" data-scroll-target="#steps-for-moving-block-bootstrap-mbb">Steps for Moving Block Bootstrap (MBB):</a></li>
  </ul></li>
  <li><a href="#assignment-3" id="toc-assignment-3" class="nav-link" data-scroll-target="#assignment-3">Assignment 3</a>
  <ul class="collapse">
  <li><a href="#task" id="toc-task" class="nav-link" data-scroll-target="#task">Task</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Computational Tools for Macroeconometrics</h1>
<p class="subtitle lead">Assignment 3</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>This assignment covers two topics: Monte Carlo simulations and Bootstrap, with a focus on time series models. As usual, I will discuss the basic ideas behind the concepts and then present the assignment.</p>
<section id="monte-carlo-experiments" class="level2">
<h2 class="anchored" data-anchor-id="monte-carlo-experiments">Monte Carlo experiments</h2>
<p>Monte Carlo experiments is a handy tool to assess the quality of the asymptotic approximation of econometric estimators.</p>
<p>Consider the following linear model <span class="math display">\[
y_t = \beta^o_0 + \beta^o_1 x_t + u_t, t = 1,\dots, T,
\]</span> where <span class="math inline">\(y_t\)</span>, <span class="math inline">\(x_t\)</span>, and <span class="math inline">\(u_t\)</span> are random variables and <span class="math inline">\(\beta^o_0\)</span> and <span class="math inline">\(\beta^o_1\)</span> are parameters to be estimated. In matrix form, the model can be written as <span class="math display">\[
Y_t = \mathbf{X}_t \beta^o + U_t,
\]</span> where <span class="math display">\[
\underbracket{Y}_{(T\times 1)}=\begin{pmatrix}Y_{1}\\
\vdots\\
Y_{T}
\end{pmatrix},\,\underbracket{\mathbf{X}}_{T\times 2}=\begin{pmatrix}1 &amp; x_{1}\\
\vdots &amp; \vdots\\
1 &amp; x_{T}
\end{pmatrix},\,\underbracket{U}_{(T\times 1)}=\begin{pmatrix}u_{1}\\
\vdots\\
u_{T}
\end{pmatrix},\,\underbracket{\beta^{o}}_{(2\times 1)}=\begin{pmatrix}\beta_{0}^{o}\\
\beta_{1}^{o}
\end{pmatrix}
\]</span></p>
<p>We will assume that 1. <span class="math inline">\((u_t, x_t)\)</span> are i.i.d. over <span class="math inline">\(t\)</span>; 2. <span class="math inline">\(E(u_t|x_t) = 0\)</span>, <span class="math inline">\(t=1,\dots,T\)</span>; 3. <span class="math inline">\(E(|x_t|^4)&lt;\infty\)</span> and <span class="math inline">\(E(|u_t|^4)&lt;\infty\)</span>; 4. <span class="math inline">\(E(u^t|x_t) = \sigma^2&gt;0\)</span>.</p>
<p>Under these assumptions, the OLS estimator of <span class="math inline">\(\beta^o\)</span>, <span class="math display">\[
\hat{\beta}^{ols} = \left(\mathbf{X}'\mathbf{X}\right)^{-1}\mathbf{X}'Y
\]</span> is unbiased, consistent, and asymptotically normal: <span class="math display">\[
E(\hat{\beta}^{ols}) = \beta^o, \,\,\, \hat{\beta}^{ols} \xrightarrow{p} \beta^o,\,\,\, \left(\hat{\beta}^{ols}-\beta^o\right) \xrightarrow{d} N\left[0, \sigma^2E\left(\mathbf{X}'\mathbf{X}\right)^{-1}\right].
\]</span></p>
<p>These results are derived theoretically. For unbiasedness, the law of iterated expectations and the iid of <span class="math inline">\((u_t,x_t)\)</span> gives <span class="math display">\[
E\left(E\left(\hat{\beta}^{ols}|\mathbf{X}\right)\right)=\beta^{o}+E\left(\left(\mathbf{X}'\mathbf{X}\right)^{-1}\mathbf{X}'E(U|\mathbf{X})\right)=\beta^{o}.
\]</span> Under the iid assumption and the restrictions on the fourth moments of <span class="math inline">\(u_t\)</span> and <span class="math inline">\(x_t\)</span>, we have <span class="math display">\[
\frac{1}{T}\mathbf{X}'U=\frac{1}{n}\sum_{t=1}^{T}\begin{pmatrix}u_{t}\\
x_{t}u_{t},
\end{pmatrix}\xrightarrow{p}\begin{pmatrix}0\\
0
\end{pmatrix},\text{ and }\frac{1}{T}\mathbf{X}'\mathbf{X}=\frac{1}{T}\sum_{t=1}^{T}\begin{pmatrix}1 &amp; x_{t}\\
x_{t}, &amp; x_{t}^{2}
\end{pmatrix}\xrightarrow{p}\begin{pmatrix}1 &amp; E(x_{t})\\
E(x_{t}), &amp; E(x_{t}^{2})
\end{pmatrix}.
\]</span> These convergences in probability deliver consistency of the OLS estimator <span class="math display">\[
\hat{\beta}^{ols}=\beta^{o}+\left(\frac{1}{T}\mathbf{X}'\mathbf{X}\right)^{-1}\frac{1}{T}\mathbf{X}'U\xrightarrow{p}\beta^{o}+\begin{pmatrix}1 &amp; E(x_{t})\\
E(x_{t}), &amp; E(x_{t}^{2})
\end{pmatrix}^{-1}\begin{pmatrix}0\\
0
\end{pmatrix}=\beta^{o}.
\]</span> Finally, iid, the moments’ restrictions, and the homoskedasticity assumptions, give <span class="math display">\[
\sqrt{T}\left(\hat{\beta}^{ols}-\beta^{o}\right)\xrightarrow{d}N\left[0,\sigma^{2}\begin{pmatrix}1 &amp; E(x_{t})\\
E(x_{t}), &amp; E(x_{t}^{2})
\end{pmatrix}^{-1}\right].
\]</span></p>
<p>Consistency and asymptotic results, and they hold as <span class="math inline">\(T\to\infty\)</span>. Given a sample of size <span class="math inline">\(T\)</span>, say <span class="math inline">\(T=50\)</span>, how close is the distribution of <span class="math inline">\(\hat{\beta}^o\)</span> the normal one postulated by the usual asymptotic theory? How close is <span class="math inline">\(\hat{\beta}^o\)</span> to <span class="math inline">\(\beta^o\)</span>? Unfortunately, theory only tells us that the larger the sample size, the better the normal approximation. Similarly, it tells us that <span class="math inline">\(\hat{\beta}^o-\beta^o\)</span> is smaller the larger the sample size.</p>
<p>Monte Carlo simulations can help us determine how good these approximations are for a given size of <span class="math inline">\(T\)</span>. The idea is simple: we simulate a sample of <span class="math inline">\((u_t, x_t)\)</span>, <span class="math inline">\(t=1,\ldots,T\)</span> from which we generate <span class="math inline">\(y_t\)</span> (using a arbitrary value for <span class="math inline">\(\beta^o_0\)</span> and <span class="math inline">\(\beta^o_1\)</span>.) We estimate the parameters using the simulated data. We repeat this operation many times, saving the estimated parameters. The saved parameters give the empirical distribution of the OLS estimator and help verify how closely the theory matches the empirical distribution.</p>
<p>The following code does a Monte Carlo for the linear model above:</p>
<div id="1dd541b7" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="im">from</span> scipy.stats <span class="im">import</span> norm</span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="co"># Set parameters</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>T <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>beta_0_true <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>beta_1_true <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb1-9"><a href="#cb1-9"></a>sigma <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb1-10"><a href="#cb1-10"></a>num_simulations <span class="op">=</span> <span class="dv">10000</span></span>
<span id="cb1-11"><a href="#cb1-11"></a></span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="co"># Arrays to store the estimates from each simulation</span></span>
<span id="cb1-13"><a href="#cb1-13"></a>beta_0_estimates <span class="op">=</span> np.zeros(num_simulations)</span>
<span id="cb1-14"><a href="#cb1-14"></a>beta_1_estimates <span class="op">=</span> np.zeros(num_simulations)</span>
<span id="cb1-15"><a href="#cb1-15"></a></span>
<span id="cb1-16"><a href="#cb1-16"></a><span class="co"># Run simulations</span></span>
<span id="cb1-17"><a href="#cb1-17"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(num_simulations):</span>
<span id="cb1-18"><a href="#cb1-18"></a> x <span class="op">=</span> np.random.normal(<span class="dv">0</span>, <span class="dv">1</span>, T)</span>
<span id="cb1-19"><a href="#cb1-19"></a> u <span class="op">=</span> np.random.normal(<span class="dv">0</span>, sigma, T)</span>
<span id="cb1-20"><a href="#cb1-20"></a> y <span class="op">=</span> beta_0_true <span class="op">+</span> beta_1_true <span class="op">*</span> x <span class="op">+</span> u</span>
<span id="cb1-21"><a href="#cb1-21"></a></span>
<span id="cb1-22"><a href="#cb1-22"></a>    <span class="co"># OLS estimation</span></span>
<span id="cb1-23"><a href="#cb1-23"></a> X <span class="op">=</span> np.vstack([np.ones(T), x]).T</span>
<span id="cb1-24"><a href="#cb1-24"></a> beta_hat <span class="op">=</span> np.linalg.inv(X.T <span class="op">@</span> X) <span class="op">@</span> X.T <span class="op">@</span> y</span>
<span id="cb1-25"><a href="#cb1-25"></a> beta_0_estimates[i] <span class="op">=</span> beta_hat[<span class="dv">0</span>]</span>
<span id="cb1-26"><a href="#cb1-26"></a> beta_1_estimates[i] <span class="op">=</span> beta_hat[<span class="dv">1</span>]</span>
<span id="cb1-27"><a href="#cb1-27"></a></span>
<span id="cb1-28"><a href="#cb1-28"></a><span class="co"># Plotting the results</span></span>
<span id="cb1-29"><a href="#cb1-29"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">4</span>))</span>
<span id="cb1-30"><a href="#cb1-30"></a></span>
<span id="cb1-31"><a href="#cb1-31"></a><span class="co"># Distribution of beta_0</span></span>
<span id="cb1-32"><a href="#cb1-32"></a>ax[<span class="dv">0</span>].hist(beta_0_estimates, bins<span class="op">=</span><span class="dv">100</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, density<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-33"><a href="#cb1-33"></a>xmin, xmax <span class="op">=</span> ax[<span class="dv">0</span>].get_xlim()</span>
<span id="cb1-34"><a href="#cb1-34"></a>x <span class="op">=</span> np.linspace(xmin, xmax, <span class="dv">100</span>)</span>
<span id="cb1-35"><a href="#cb1-35"></a>p <span class="op">=</span> norm.pdf(x, beta_0_true, <span class="dv">1</span><span class="op">/</span>np.sqrt(T))</span>
<span id="cb1-36"><a href="#cb1-36"></a>ax[<span class="dv">0</span>].plot(x, p, <span class="st">'k'</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb1-37"><a href="#cb1-37"></a>ax[<span class="dv">0</span>].set_title(<span class="ss">f'Empirical vs. Normal Approximation for $</span><span class="ch">\\</span><span class="ss">hat</span><span class="ch">{{\\</span><span class="ss">beta</span><span class="ch">}}</span><span class="ss">_0$'</span>)</span>
<span id="cb1-38"><a href="#cb1-38"></a></span>
<span id="cb1-39"><a href="#cb1-39"></a><span class="co"># Distribution of beta_1</span></span>
<span id="cb1-40"><a href="#cb1-40"></a>ax[<span class="dv">1</span>].hist(beta_1_estimates, bins<span class="op">=</span><span class="dv">100</span>, alpha<span class="op">=</span><span class="fl">0.50</span>, density<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-41"><a href="#cb1-41"></a>xmin, xmax <span class="op">=</span> ax[<span class="dv">1</span>].get_xlim()</span>
<span id="cb1-42"><a href="#cb1-42"></a>x <span class="op">=</span> np.linspace(xmin, xmax, <span class="dv">100</span>)</span>
<span id="cb1-43"><a href="#cb1-43"></a>p <span class="op">=</span> norm.pdf(x, beta_1_true, <span class="dv">1</span><span class="op">/</span>np.sqrt(T))</span>
<span id="cb1-44"><a href="#cb1-44"></a>ax[<span class="dv">1</span>].plot(x, p, <span class="st">'k'</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb1-45"><a href="#cb1-45"></a>ax[<span class="dv">1</span>].set_title(<span class="ss">f'Empirical vs. Normal Approximation'</span>)</span>
<span id="cb1-46"><a href="#cb1-46"></a></span>
<span id="cb1-47"><a href="#cb1-47"></a>plt.tight_layout()</span>
<span id="cb1-48"><a href="#cb1-48"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="comptools_ass3_files/figure-html/cell-2-output-1.png" width="758" height="373" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>The approximation is excellent, even if <span class="math inline">\(T=20\)</span>. This might sound surprising since the normal distribution of <span class="math inline">\(\hat{\beta}^{ols}\)</span> is normal when <span class="math inline">\(T\)</span> is large. We get such a close agreement between the empirical distribution of <span class="math inline">\(\hat{\beta}^{ols}\)</span> and the theoretical one because we are simulating <span class="math inline">\(u_t\)</span> the data from a normal distribution independently from <span class="math inline">\(x_t\)</span>. When <span class="math inline">\(u_t|x_t\sim N(0,\sigma^2)\)</span>, the distribution of the OLS estimator is precisely normal, even when <span class="math inline">\(T=3\)</span>. Of course, if <span class="math inline">\(T\)</span> is small, the estimator’s variance will be larger, but a normal distribution will approximate the OLS estimators’ distribution.</p>
<p>Instead of squinting at the histograms and the density implied by the CLT, we can modify the code to calculate the confidence interval at each simulation and see how many times the “true” values of the parameters fall into all the intervals generated. If the approximation is good, a 95% confidence interval should contain the “true” parameters 95% of the time.</p>
<div id="004ace5a" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="im">from</span> scipy.stats <span class="im">import</span> norm</span>
<span id="cb2-4"><a href="#cb2-4"></a></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="co"># Set parameters</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>T <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>beta_0_true <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>beta_1_true <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>sigma <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb2-10"><a href="#cb2-10"></a>num_simulations <span class="op">=</span> <span class="dv">10000</span></span>
<span id="cb2-11"><a href="#cb2-11"></a></span>
<span id="cb2-12"><a href="#cb2-12"></a><span class="co"># Arrays to store the estimates from each simulation</span></span>
<span id="cb2-13"><a href="#cb2-13"></a>beta_0_estimates <span class="op">=</span> np.zeros(num_simulations)</span>
<span id="cb2-14"><a href="#cb2-14"></a>beta_1_estimates <span class="op">=</span> np.zeros(num_simulations)</span>
<span id="cb2-15"><a href="#cb2-15"></a>beta_0_in <span class="op">=</span> np.zeros(num_simulations)</span>
<span id="cb2-16"><a href="#cb2-16"></a>beta_1_in <span class="op">=</span> np.zeros(num_simulations)</span>
<span id="cb2-17"><a href="#cb2-17"></a></span>
<span id="cb2-18"><a href="#cb2-18"></a><span class="co"># Run simulations</span></span>
<span id="cb2-19"><a href="#cb2-19"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(num_simulations):</span>
<span id="cb2-20"><a href="#cb2-20"></a> x <span class="op">=</span> np.random.normal(<span class="dv">0</span>,<span class="dv">1</span>,T)</span>
<span id="cb2-21"><a href="#cb2-21"></a> u <span class="op">=</span> np.random.normal(<span class="dv">0</span>,sigma,T)</span>
<span id="cb2-22"><a href="#cb2-22"></a> y <span class="op">=</span> beta_0_true <span class="op">+</span> beta_1_true <span class="op">*</span> x <span class="op">+</span> u</span>
<span id="cb2-23"><a href="#cb2-23"></a>    <span class="co"># OLS estimation</span></span>
<span id="cb2-24"><a href="#cb2-24"></a> X <span class="op">=</span> np.vstack([np.ones(T), x]).T</span>
<span id="cb2-25"><a href="#cb2-25"></a> XXinv <span class="op">=</span> np.linalg.inv(X.T <span class="op">@</span> X)</span>
<span id="cb2-26"><a href="#cb2-26"></a> beta_hat <span class="op">=</span> XXinv <span class="op">@</span> X.T <span class="op">@</span> y</span>
<span id="cb2-27"><a href="#cb2-27"></a> beta_0_estimates[i] <span class="op">=</span> beta_hat[<span class="dv">0</span>]</span>
<span id="cb2-28"><a href="#cb2-28"></a> beta_1_estimates[i] <span class="op">=</span> beta_hat[<span class="dv">1</span>]</span>
<span id="cb2-29"><a href="#cb2-29"></a> u_hat <span class="op">=</span> y <span class="op">-</span> beta_hat[<span class="dv">0</span>] <span class="op">-</span> beta_hat[<span class="dv">1</span>] <span class="op">*</span> x</span>
<span id="cb2-30"><a href="#cb2-30"></a> sigma2_hat <span class="op">=</span> np.dot(u_hat, u_hat)<span class="op">/</span>(T<span class="op">-</span><span class="dv">2</span>)</span>
<span id="cb2-31"><a href="#cb2-31"></a> variance_hat <span class="op">=</span> sigma2_hat<span class="op">*</span>XXinv</span>
<span id="cb2-32"><a href="#cb2-32"></a> se_0 <span class="op">=</span> np.sqrt(variance_hat[<span class="dv">0</span>,<span class="dv">0</span>])</span>
<span id="cb2-33"><a href="#cb2-33"></a> se_1 <span class="op">=</span> np.sqrt(variance_hat[<span class="dv">1</span>,<span class="dv">1</span>])</span>
<span id="cb2-34"><a href="#cb2-34"></a>    <span class="co">## Check weather beta_0 in CI 95%</span></span>
<span id="cb2-35"><a href="#cb2-35"></a> beta_0_in[i] <span class="op">=</span> beta_hat[<span class="dv">0</span>] <span class="op">-</span> <span class="fl">1.965</span><span class="op">*</span>se_0 <span class="op">&lt;</span> beta_0_true <span class="op">&lt;</span> beta_hat[<span class="dv">0</span>] <span class="op">+</span> <span class="fl">1.965</span><span class="op">*</span>se_0</span>
<span id="cb2-36"><a href="#cb2-36"></a> beta_1_in[i] <span class="op">=</span> beta_hat[<span class="dv">1</span>] <span class="op">-</span> <span class="fl">1.965</span><span class="op">*</span>se_1 <span class="op">&lt;</span> beta_1_true <span class="op">&lt;</span> beta_hat[<span class="dv">1</span>] <span class="op">+</span> <span class="fl">1.965</span><span class="op">*</span>se_1</span>
<span id="cb2-37"><a href="#cb2-37"></a></span>
<span id="cb2-38"><a href="#cb2-38"></a><span class="co"># Output the results</span></span>
<span id="cb2-39"><a href="#cb2-39"></a><span class="bu">print</span>(<span class="ss">f"Empirical 95% CI for beta_0: </span><span class="sc">{</span>np<span class="sc">.</span>mean(beta_0_in)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb2-40"><a href="#cb2-40"></a><span class="bu">print</span>(<span class="ss">f"Empirical 95% CI for beta_1: </span><span class="sc">{</span>np<span class="sc">.</span>mean(beta_1_in)<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Empirical 95% CI for beta_0: 0.9457
Empirical 95% CI for beta_1: 0.9428</code></pre>
</div>
</div>
<p>The empirical coverage of the confidence intervals is only in the neighborhood of 95%. The reason is that we are estimating the variance of the coefficient, and in this case, the distribution of <span class="math inline">\(\hat{\beta}_1/se(\hat{\beta}_1)\)</span> has a <span class="math inline">\(t\)</span>-student distribution with <span class="math inline">\(T-1\)</span> degrees of freedom. If you run the code above for <span class="math inline">\(T=50\)</span>, the confidence interval coverage will be closer to 95%.</p>
<p>Let us see what happens if we simulate <span class="math inline">\(x_t\)</span> and <span class="math inline">\(u_t\)</span> from a chi-squared distribution with <span class="math inline">\(5\)</span> of freedom centered in a way to have mean zero and unit variance.</p>
<div id="33732306" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="im">from</span> scipy.stats <span class="im">import</span> norm</span>
<span id="cb4-4"><a href="#cb4-4"></a></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="co"># Set parameters</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>T <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb4-7"><a href="#cb4-7"></a>beta_0_true <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb4-8"><a href="#cb4-8"></a>beta_1_true <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb4-9"><a href="#cb4-9"></a>sigma <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb4-10"><a href="#cb4-10"></a>num_simulations <span class="op">=</span> <span class="dv">10000</span></span>
<span id="cb4-11"><a href="#cb4-11"></a></span>
<span id="cb4-12"><a href="#cb4-12"></a><span class="co"># Arrays to store the estimates from each simulation</span></span>
<span id="cb4-13"><a href="#cb4-13"></a>beta_0_estimates <span class="op">=</span> np.zeros(num_simulations)</span>
<span id="cb4-14"><a href="#cb4-14"></a>beta_1_estimates <span class="op">=</span> np.zeros(num_simulations)</span>
<span id="cb4-15"><a href="#cb4-15"></a>beta_0_in <span class="op">=</span> np.zeros(num_simulations)</span>
<span id="cb4-16"><a href="#cb4-16"></a>beta_1_in <span class="op">=</span> np.zeros(num_simulations)</span>
<span id="cb4-17"><a href="#cb4-17"></a></span>
<span id="cb4-18"><a href="#cb4-18"></a><span class="co"># Run simulations</span></span>
<span id="cb4-19"><a href="#cb4-19"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(num_simulations):</span>
<span id="cb4-20"><a href="#cb4-20"></a> x <span class="op">=</span> (np.random.chisquare(<span class="dv">4</span>,T) <span class="op">-</span> <span class="dv">4</span>)<span class="op">/</span>np.sqrt(<span class="dv">2</span><span class="op">*</span><span class="dv">4</span>)</span>
<span id="cb4-21"><a href="#cb4-21"></a> u <span class="op">=</span> (np.random.chisquare(<span class="dv">4</span>,T) <span class="op">-</span> <span class="dv">4</span>)<span class="op">/</span>np.sqrt(<span class="dv">2</span><span class="op">*</span><span class="dv">4</span>)</span>
<span id="cb4-22"><a href="#cb4-22"></a> y <span class="op">=</span> beta_0_true <span class="op">+</span> beta_1_true <span class="op">*</span> x <span class="op">+</span> u</span>
<span id="cb4-23"><a href="#cb4-23"></a>    <span class="co"># OLS estimation</span></span>
<span id="cb4-24"><a href="#cb4-24"></a> X <span class="op">=</span> np.vstack([np.ones(T), x]).T</span>
<span id="cb4-25"><a href="#cb4-25"></a> XXinv <span class="op">=</span> np.linalg.inv(X.T <span class="op">@</span> X)</span>
<span id="cb4-26"><a href="#cb4-26"></a> beta_hat <span class="op">=</span> XXinv <span class="op">@</span> X.T <span class="op">@</span> y</span>
<span id="cb4-27"><a href="#cb4-27"></a> beta_0_estimates[i] <span class="op">=</span> beta_hat[<span class="dv">0</span>]</span>
<span id="cb4-28"><a href="#cb4-28"></a> beta_1_estimates[i] <span class="op">=</span> beta_hat[<span class="dv">1</span>]</span>
<span id="cb4-29"><a href="#cb4-29"></a> u_hat <span class="op">=</span> y <span class="op">-</span> beta_hat[<span class="dv">0</span>] <span class="op">-</span> beta_hat[<span class="dv">1</span>] <span class="op">*</span> x</span>
<span id="cb4-30"><a href="#cb4-30"></a> sigma2_hat <span class="op">=</span> np.dot(u_hat, u_hat)<span class="op">/</span>(T<span class="op">-</span><span class="dv">2</span>)</span>
<span id="cb4-31"><a href="#cb4-31"></a> variance_hat <span class="op">=</span> sigma2_hat<span class="op">*</span>XXinv</span>
<span id="cb4-32"><a href="#cb4-32"></a> se_0 <span class="op">=</span> np.sqrt(variance_hat[<span class="dv">0</span>,<span class="dv">0</span>])</span>
<span id="cb4-33"><a href="#cb4-33"></a> se_1 <span class="op">=</span> np.sqrt(variance_hat[<span class="dv">1</span>,<span class="dv">1</span>])</span>
<span id="cb4-34"><a href="#cb4-34"></a>    <span class="co">## Check weather beta_0 in CI 95%</span></span>
<span id="cb4-35"><a href="#cb4-35"></a> beta_0_in[i] <span class="op">=</span> beta_hat[<span class="dv">0</span>] <span class="op">-</span> <span class="fl">1.965</span><span class="op">*</span>se_0 <span class="op">&lt;</span> beta_0_true <span class="op">&lt;</span> beta_hat[<span class="dv">0</span>] <span class="op">+</span> <span class="fl">1.965</span><span class="op">*</span>se_0</span>
<span id="cb4-36"><a href="#cb4-36"></a> beta_1_in[i] <span class="op">=</span> beta_hat[<span class="dv">1</span>] <span class="op">-</span> <span class="fl">1.965</span><span class="op">*</span>se_1 <span class="op">&lt;</span> beta_1_true <span class="op">&lt;</span> beta_hat[<span class="dv">1</span>] <span class="op">+</span> <span class="fl">1.965</span><span class="op">*</span>se_1</span>
<span id="cb4-37"><a href="#cb4-37"></a></span>
<span id="cb4-38"><a href="#cb4-38"></a><span class="co"># Output the results</span></span>
<span id="cb4-39"><a href="#cb4-39"></a><span class="bu">print</span>(<span class="ss">f"Empirical 95% CI for beta_0: </span><span class="sc">{</span>np<span class="sc">.</span>mean(beta_0_in)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb4-40"><a href="#cb4-40"></a><span class="bu">print</span>(<span class="ss">f"Empirical 95% CI for beta_1: </span><span class="sc">{</span>np<span class="sc">.</span>mean(beta_1_in)<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Empirical 95% CI for beta_0: 0.9397
Empirical 95% CI for beta_1: 0.9485</code></pre>
</div>
</div>
<p>Even a <span class="math inline">\(T=50\)</span>, there is some difference between the empirical and theoretical coverage.</p>
<p>We can use the simulations to see what happens when the conditions on the moments of <span class="math inline">\(u_t\)</span> and <span class="math inline">\(x_t\)</span> are unsatisfied.</p>
<div id="cd40a1f2" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="im">from</span> scipy.stats <span class="im">import</span> norm</span>
<span id="cb6-4"><a href="#cb6-4"></a></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="co"># Set parameters</span></span>
<span id="cb6-6"><a href="#cb6-6"></a>T <span class="op">=</span> <span class="dv">150</span></span>
<span id="cb6-7"><a href="#cb6-7"></a>beta_0_true <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb6-8"><a href="#cb6-8"></a>beta_1_true <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb6-9"><a href="#cb6-9"></a>sigma <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb6-10"><a href="#cb6-10"></a>num_simulations <span class="op">=</span> <span class="dv">10000</span></span>
<span id="cb6-11"><a href="#cb6-11"></a></span>
<span id="cb6-12"><a href="#cb6-12"></a><span class="co"># Arrays to store the estimates from each simulation</span></span>
<span id="cb6-13"><a href="#cb6-13"></a>beta_0_estimates <span class="op">=</span> np.zeros(num_simulations)</span>
<span id="cb6-14"><a href="#cb6-14"></a>beta_1_estimates <span class="op">=</span> np.zeros(num_simulations)</span>
<span id="cb6-15"><a href="#cb6-15"></a>beta_0_in <span class="op">=</span> np.zeros(num_simulations)</span>
<span id="cb6-16"><a href="#cb6-16"></a>beta_1_in <span class="op">=</span> np.zeros(num_simulations)</span>
<span id="cb6-17"><a href="#cb6-17"></a></span>
<span id="cb6-18"><a href="#cb6-18"></a><span class="co"># Run simulations</span></span>
<span id="cb6-19"><a href="#cb6-19"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(num_simulations):</span>
<span id="cb6-20"><a href="#cb6-20"></a> x <span class="op">=</span> np.random.standard_cauchy(T)</span>
<span id="cb6-21"><a href="#cb6-21"></a> u <span class="op">=</span> np.random.standard_cauchy(T)</span>
<span id="cb6-22"><a href="#cb6-22"></a> y <span class="op">=</span> beta_0_true <span class="op">+</span> beta_1_true <span class="op">*</span> x <span class="op">+</span> u</span>
<span id="cb6-23"><a href="#cb6-23"></a>    <span class="co"># OLS estimation</span></span>
<span id="cb6-24"><a href="#cb6-24"></a> X <span class="op">=</span> np.vstack([np.ones(T), x]).T</span>
<span id="cb6-25"><a href="#cb6-25"></a> XXinv <span class="op">=</span> np.linalg.inv(X.T <span class="op">@</span> X)</span>
<span id="cb6-26"><a href="#cb6-26"></a> beta_hat <span class="op">=</span> XXinv <span class="op">@</span> X.T <span class="op">@</span> y</span>
<span id="cb6-27"><a href="#cb6-27"></a> beta_0_estimates[i] <span class="op">=</span> beta_hat[<span class="dv">0</span>]</span>
<span id="cb6-28"><a href="#cb6-28"></a> beta_1_estimates[i] <span class="op">=</span> beta_hat[<span class="dv">1</span>]</span>
<span id="cb6-29"><a href="#cb6-29"></a> u_hat <span class="op">=</span> y <span class="op">-</span> beta_hat[<span class="dv">0</span>] <span class="op">-</span> beta_hat[<span class="dv">1</span>] <span class="op">*</span> x</span>
<span id="cb6-30"><a href="#cb6-30"></a> sigma2_hat <span class="op">=</span> np.dot(u_hat, u_hat)<span class="op">/</span>(T<span class="op">-</span><span class="dv">2</span>)</span>
<span id="cb6-31"><a href="#cb6-31"></a> variance_hat <span class="op">=</span> sigma2_hat<span class="op">*</span>XXinv</span>
<span id="cb6-32"><a href="#cb6-32"></a> se_0 <span class="op">=</span> np.sqrt(variance_hat[<span class="dv">0</span>,<span class="dv">0</span>])</span>
<span id="cb6-33"><a href="#cb6-33"></a> se_1 <span class="op">=</span> np.sqrt(variance_hat[<span class="dv">1</span>,<span class="dv">1</span>])</span>
<span id="cb6-34"><a href="#cb6-34"></a>    <span class="co">## Check weather beta_0 in CI 95%</span></span>
<span id="cb6-35"><a href="#cb6-35"></a> beta_0_in[i] <span class="op">=</span> beta_hat[<span class="dv">0</span>] <span class="op">-</span> <span class="fl">1.965</span><span class="op">*</span>se_0 <span class="op">&lt;</span> beta_0_true <span class="op">&lt;</span> beta_hat[<span class="dv">0</span>] <span class="op">+</span> <span class="fl">1.965</span><span class="op">*</span>se_0</span>
<span id="cb6-36"><a href="#cb6-36"></a> beta_1_in[i] <span class="op">=</span> beta_hat[<span class="dv">1</span>] <span class="op">-</span> <span class="fl">1.965</span><span class="op">*</span>se_1 <span class="op">&lt;</span> beta_1_true <span class="op">&lt;</span> beta_hat[<span class="dv">1</span>] <span class="op">+</span> <span class="fl">1.965</span><span class="op">*</span>se_1</span>
<span id="cb6-37"><a href="#cb6-37"></a></span>
<span id="cb6-38"><a href="#cb6-38"></a><span class="co"># Output the results</span></span>
<span id="cb6-39"><a href="#cb6-39"></a><span class="bu">print</span>(<span class="ss">f"Empirical 95% CI for beta_0: </span><span class="sc">{</span>np<span class="sc">.</span>mean(beta_0_in)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb6-40"><a href="#cb6-40"></a><span class="bu">print</span>(<span class="ss">f"Empirical 95% CI for beta_1: </span><span class="sc">{</span>np<span class="sc">.</span>mean(beta_1_in)<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Empirical 95% CI for beta_0: 0.9764
Empirical 95% CI for beta_1: 0.9541</code></pre>
</div>
</div>
</section>
<section id="bootstrap" class="level2">
<h2 class="anchored" data-anchor-id="bootstrap">Bootstrap</h2>
<p>The <em>bootstrap</em> is a statistical tool for estimating the distribution of a statistic based on random sampling with replacement. It allows for assessing a statistic’s variability and is beneficial in settings where the theoretical distribution of the statistic is unknown or difficult to derive.</p>
<p>In the context of a linear regression model, we can use the bootstrap to perform inference on the regression coefficients. Despite its theoretical intricacies, the bootstrap is conceptually simple and describing its application can be done quite easily.</p>
<p>Input: Dataset <span class="math inline">\((X, y)\)</span> with <span class="math inline">\(n\)</span> observations Fit original model: Estimate coefficients <span class="math inline">\(\beta\)</span> from original dataset Store these coefficients coefficients Bootstrap procedure: For <span class="math inline">\(b = 1\)</span> to $ (number of bootstrap samples): Create “bootstrap” sample <span class="math inline">\((X^*, y^*)\)</span> by randomly sampling <span class="math inline">\(n\)</span> observations with replacement from original dataset Fit linear model to bootstrap sample Estimate and store bootstrap coefficients <span class="math inline">\(\beta^*\)</span> Calculate statistics: Compute variance of bootstrap coefficient estimates Optionally calculate confidence intervals using percentiles of bootstrap distribution Output: Original coefficients, bootstrap variance estimates, confidence intervals</p>
<div id="ff39f5d5" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb8-2"><a href="#cb8-2"></a></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="co"># Set random seed for reproducibility</span></span>
<span id="cb8-4"><a href="#cb8-4"></a>np.random.seed(<span class="dv">0</span>)</span>
<span id="cb8-5"><a href="#cb8-5"></a></span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="co"># Generate some sample data</span></span>
<span id="cb8-7"><a href="#cb8-7"></a>T <span class="op">=</span> <span class="dv">100</span>  <span class="co"># Number of observations</span></span>
<span id="cb8-8"><a href="#cb8-8"></a>x <span class="op">=</span> np.random.normal(<span class="dv">0</span>, <span class="dv">1</span>, T)</span>
<span id="cb8-9"><a href="#cb8-9"></a>u <span class="op">=</span> np.random.normal(<span class="dv">0</span>, <span class="dv">1</span>, T)</span>
<span id="cb8-10"><a href="#cb8-10"></a>beta_0_true <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb8-11"><a href="#cb8-11"></a>beta_1_true <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb8-12"><a href="#cb8-12"></a></span>
<span id="cb8-13"><a href="#cb8-13"></a><span class="co"># Simulate response variable y</span></span>
<span id="cb8-14"><a href="#cb8-14"></a>y <span class="op">=</span> beta_0_true <span class="op">+</span> beta_1_true <span class="op">*</span> x <span class="op">+</span> u</span>
<span id="cb8-15"><a href="#cb8-15"></a></span>
<span id="cb8-16"><a href="#cb8-16"></a><span class="co"># Function to fit linear model</span></span>
<span id="cb8-17"><a href="#cb8-17"></a><span class="kw">def</span> fit_linear_model(x, y):</span>
<span id="cb8-18"><a href="#cb8-18"></a>  X <span class="op">=</span> np.vstack([np.ones(<span class="bu">len</span>(x)), x]).T</span>
<span id="cb8-19"><a href="#cb8-19"></a>  beta_hat <span class="op">=</span> np.linalg.inv(X.T <span class="op">@</span> X) <span class="op">@</span> (X.T <span class="op">@</span> y)</span>
<span id="cb8-20"><a href="#cb8-20"></a>  <span class="cf">return</span> beta_hat</span>
<span id="cb8-21"><a href="#cb8-21"></a></span>
<span id="cb8-22"><a href="#cb8-22"></a><span class="co"># Initial fit</span></span>
<span id="cb8-23"><a href="#cb8-23"></a>initial_beta <span class="op">=</span> fit_linear_model(x, y)</span>
<span id="cb8-24"><a href="#cb8-24"></a></span>
<span id="cb8-25"><a href="#cb8-25"></a><span class="co"># Number of bootstrap samples</span></span>
<span id="cb8-26"><a href="#cb8-26"></a>B <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb8-27"><a href="#cb8-27"></a>bootstrap_estimates <span class="op">=</span> np.zeros((B, <span class="dv">2</span>))</span>
<span id="cb8-28"><a href="#cb8-28"></a></span>
<span id="cb8-29"><a href="#cb8-29"></a><span class="co"># Perform bootstrap resampling</span></span>
<span id="cb8-30"><a href="#cb8-30"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(B):</span>
<span id="cb8-31"><a href="#cb8-31"></a>  indices <span class="op">=</span> np.random.choice(<span class="bu">range</span>(T), size<span class="op">=</span>T, replace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb8-32"><a href="#cb8-32"></a>  x_resampled <span class="op">=</span> x[indices]</span>
<span id="cb8-33"><a href="#cb8-33"></a>  y_resampled <span class="op">=</span> y[indices]</span>
<span id="cb8-34"><a href="#cb8-34"></a>  bootstrap_estimates[i] <span class="op">=</span> fit_linear_model(x_resampled, y_resampled)</span>
<span id="cb8-35"><a href="#cb8-35"></a></span>
<span id="cb8-36"><a href="#cb8-36"></a><span class="co"># Compute standard errors</span></span>
<span id="cb8-37"><a href="#cb8-37"></a>standard_errors <span class="op">=</span> bootstrap_estimates.std(axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb8-38"><a href="#cb8-38"></a></span>
<span id="cb8-39"><a href="#cb8-39"></a><span class="bu">print</span>(<span class="st">"Bootstrap Standard Errors:"</span>)</span>
<span id="cb8-40"><a href="#cb8-40"></a><span class="bu">print</span>(<span class="st">"SE(beta_0):"</span>, standard_errors[<span class="dv">0</span>])</span>
<span id="cb8-41"><a href="#cb8-41"></a><span class="bu">print</span>(<span class="st">"SE(beta_1):"</span>, standard_errors[<span class="dv">1</span>])</span>
<span id="cb8-42"><a href="#cb8-42"></a></span>
<span id="cb8-43"><a href="#cb8-43"></a><span class="bu">print</span>(<span class="st">"LM Standard Errors:"</span>)</span>
<span id="cb8-44"><a href="#cb8-44"></a><span class="im">import</span> statsmodels.api <span class="im">as</span> sm</span>
<span id="cb8-45"><a href="#cb8-45"></a>X <span class="op">=</span> sm.add_constant(x)</span>
<span id="cb8-46"><a href="#cb8-46"></a>model <span class="op">=</span> sm.OLS(y, X)</span>
<span id="cb8-47"><a href="#cb8-47"></a>results <span class="op">=</span> model.fit()</span>
<span id="cb8-48"><a href="#cb8-48"></a></span>
<span id="cb8-49"><a href="#cb8-49"></a><span class="co"># Standard errors from statsmodels</span></span>
<span id="cb8-50"><a href="#cb8-50"></a>statsmodels_se <span class="op">=</span> results.bse</span>
<span id="cb8-51"><a href="#cb8-51"></a><span class="bu">print</span>(<span class="st">"Standard Errors from statsmodels OLS:"</span>)</span>
<span id="cb8-52"><a href="#cb8-52"></a><span class="bu">print</span>(<span class="st">"SE(beta_0):"</span>, statsmodels_se[<span class="dv">0</span>])</span>
<span id="cb8-53"><a href="#cb8-53"></a><span class="bu">print</span>(<span class="st">"SE(beta_1):"</span>, statsmodels_se[<span class="dv">1</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Bootstrap Standard Errors:
SE(beta_0): 0.10061319113712466
SE(beta_1): 0.09469134082416591
LM Standard Errors:
Standard Errors from statsmodels OLS:
SE(beta_0): 0.10404543947505016
SE(beta_1): 0.10305046686003079</code></pre>
</div>
</div>
</section>
<section id="linear-model-with-dependent-data" class="level2">
<h2 class="anchored" data-anchor-id="linear-model-with-dependent-data">Linear model with dependent data</h2>
<p>So far, we have assumed that <span class="math inline">\((u_t, x_t)\)</span> are iid. With macroeconomic data, it is often the case that <span class="math inline">\((u_t, x_t)\)</span> are correlated.</p>
<p>Consider the following model: <span class="math display">\[
y_t = \beta_0 + \beta_1 x_t + u_t,
\]</span> with <span class="math display">\[
x_t = \phi_x x_{t-1} + \eta_i,\,\, |\phi_x|&lt;1
\]</span> and <span class="math display">\[
u_t = \phi_u u_{t-1} + \varepsilon_t, \,\, |\phi_u|&lt;1.
\]</span></p>
<p>If <span class="math inline">\(\eta_i\)</span> and <span class="math inline">\(\varepsilon_t\)</span> are independent, we will have that <span class="math inline">\(E(u_t|x_t)=0\)</span> and so we can consistently estimate <span class="math inline">\(\beta_1\)</span> by OLS. The asymptotic distribution of the OLS estimator will be normal, but the variance of this distribution is difficult to estimate. If we use the standard errors that do not consider the correlation over time of the variables, the inference will be off. We perform a simple Monte Carlo to see the impact of serial correlation in <span class="math inline">\(x_t\)</span> and <span class="math inline">\(u_t\)</span>.</p>
<div id="1385431b" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">def</span> simulate_ar1(n, phi, sigma):</span>
<span id="cb10-2"><a href="#cb10-2"></a>  <span class="co">"""</span></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="co">  Simulate an AR(1) process.</span></span>
<span id="cb10-4"><a href="#cb10-4"></a></span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="co">  Parameters:</span></span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="co">  n (int): Number of observations.</span></span>
<span id="cb10-7"><a href="#cb10-7"></a><span class="co">  phi (float): Coefficient of AR(1) process.</span></span>
<span id="cb10-8"><a href="#cb10-8"></a><span class="co">  sigma (float): Standard deviation of the innovation term.</span></span>
<span id="cb10-9"><a href="#cb10-9"></a></span>
<span id="cb10-10"><a href="#cb10-10"></a><span class="co">  Returns:</span></span>
<span id="cb10-11"><a href="#cb10-11"></a><span class="co">  np.array: Simulated AR(1) error terms.</span></span>
<span id="cb10-12"><a href="#cb10-12"></a><span class="co">  """</span></span>
<span id="cb10-13"><a href="#cb10-13"></a>  errors <span class="op">=</span> np.zeros(n)</span>
<span id="cb10-14"><a href="#cb10-14"></a>  eta <span class="op">=</span> np.random.normal(<span class="dv">0</span>, sigma, n)  <span class="co"># white noise</span></span>
<span id="cb10-15"><a href="#cb10-15"></a>  <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb10-16"><a href="#cb10-16"></a>    errors[t] <span class="op">=</span> phi <span class="op">*</span> errors[t <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> eta[t]</span>
<span id="cb10-17"><a href="#cb10-17"></a>  <span class="cf">return</span> errors</span>
<span id="cb10-18"><a href="#cb10-18"></a></span>
<span id="cb10-19"><a href="#cb10-19"></a><span class="kw">def</span> simulate_regression_with_ar1_errors(n, beta0, beta1, phi_x, phi_u, sigma):</span>
<span id="cb10-20"><a href="#cb10-20"></a>  <span class="co">"""</span></span>
<span id="cb10-21"><a href="#cb10-21"></a><span class="co">  Simulate a regression model with AR(1) error terms. </span></span>
<span id="cb10-22"><a href="#cb10-22"></a><span class="co">  Parameters:</span></span>
<span id="cb10-23"><a href="#cb10-23"></a><span class="co">    n (int): Number of observations.</span></span>
<span id="cb10-24"><a href="#cb10-24"></a><span class="co">    beta0 (float): Intercept of the regression model.</span></span>
<span id="cb10-25"><a href="#cb10-25"></a><span class="co">    beta1 (float): Slope of the regression model.</span></span>
<span id="cb10-26"><a href="#cb10-26"></a><span class="co">    phi (float): Coefficient of the AR(1) process in the error term.</span></span>
<span id="cb10-27"><a href="#cb10-27"></a><span class="co">    sigma (float): Standard deviation of the innovation term in the AR(1) process.  </span></span>
<span id="cb10-28"><a href="#cb10-28"></a><span class="co">    Returns:</span></span>
<span id="cb10-29"><a href="#cb10-29"></a><span class="co">  tuple: x (independent variable), y (dependent variable), errors (AR(1) process)</span></span>
<span id="cb10-30"><a href="#cb10-30"></a><span class="co">  """</span></span>
<span id="cb10-31"><a href="#cb10-31"></a>  x <span class="op">=</span> simulate_ar1(n, phi_x, sigma)</span>
<span id="cb10-32"><a href="#cb10-32"></a>  u <span class="op">=</span> simulate_ar1(n, phi_u, sigma)</span>
<span id="cb10-33"><a href="#cb10-33"></a>  y <span class="op">=</span> beta0 <span class="op">+</span> beta1 <span class="op">*</span> x <span class="op">+</span> u</span>
<span id="cb10-34"><a href="#cb10-34"></a>  <span class="cf">return</span> x, y, u</span>
<span id="cb10-35"><a href="#cb10-35"></a></span>
<span id="cb10-36"><a href="#cb10-36"></a>T <span class="op">=</span> <span class="dv">500</span>              <span class="co"># Number of observations</span></span>
<span id="cb10-37"><a href="#cb10-37"></a>beta0 <span class="op">=</span> <span class="fl">1.</span>           <span class="co"># Intercept</span></span>
<span id="cb10-38"><a href="#cb10-38"></a>beta1 <span class="op">=</span> <span class="dv">2</span>           <span class="co"># Slope</span></span>
<span id="cb10-39"><a href="#cb10-39"></a>phi_x <span class="op">=</span> <span class="fl">0.7</span>             <span class="co"># AR(1) coefficient for x</span></span>
<span id="cb10-40"><a href="#cb10-40"></a>phi_u <span class="op">=</span> <span class="fl">0.7</span>             <span class="co"># AR(1) coefficient for the errors</span></span>
<span id="cb10-41"><a href="#cb10-41"></a>sigma <span class="op">=</span> <span class="dv">1</span>             <span class="co"># Standard deviation of the white noise</span></span>
<span id="cb10-42"><a href="#cb10-42"></a></span>
<span id="cb10-43"><a href="#cb10-43"></a><span class="co"># Simulating the model</span></span>
<span id="cb10-44"><a href="#cb10-44"></a></span>
<span id="cb10-45"><a href="#cb10-45"></a><span class="co">## Do monte carlo</span></span>
<span id="cb10-46"><a href="#cb10-46"></a>t_stats_hc <span class="op">=</span> []</span>
<span id="cb10-47"><a href="#cb10-47"></a>t_stats_hac <span class="op">=</span> []</span>
<span id="cb10-48"><a href="#cb10-48"></a></span>
<span id="cb10-49"><a href="#cb10-49"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1000</span>):</span>
<span id="cb10-50"><a href="#cb10-50"></a>  x, y, errors <span class="op">=</span> simulate_regression_with_ar1_errors(T, beta0, beta1, phi_x, phi_u, sigma)</span>
<span id="cb10-51"><a href="#cb10-51"></a>  X <span class="op">=</span> sm.add_constant(x)</span>
<span id="cb10-52"><a href="#cb10-52"></a>  model <span class="op">=</span> sm.OLS(y, X).fit(cov_type<span class="op">=</span><span class="st">'HC1'</span>)</span>
<span id="cb10-53"><a href="#cb10-53"></a>  t_stats_hc.append(model.t_test(<span class="st">'x1=2'</span>).tvalue)</span>
<span id="cb10-54"><a href="#cb10-54"></a>     <span class="co">## Use HAC: takes into account serial correlation </span></span>
<span id="cb10-55"><a href="#cb10-55"></a>  model2 <span class="op">=</span> sm.OLS(y, X).fit(cov_type<span class="op">=</span><span class="st">'HAC'</span>, cov_kwds<span class="op">=</span>{<span class="st">'maxlags'</span>: np.floor(<span class="fl">1.3</span><span class="op">*</span>T<span class="op">**</span>(<span class="dv">1</span><span class="op">/</span><span class="dv">2</span>)).astype(<span class="bu">int</span>)})</span>
<span id="cb10-56"><a href="#cb10-56"></a>  t_stats_hac.append(model2.t_test(<span class="st">'x1=2'</span>).tvalue)  </span>
<span id="cb10-57"><a href="#cb10-57"></a></span>
<span id="cb10-58"><a href="#cb10-58"></a><span class="co">## Check we reject the null hypothesis at alpha=0.05 about 5% of the time</span></span>
<span id="cb10-59"><a href="#cb10-59"></a></span>
<span id="cb10-60"><a href="#cb10-60"></a><span class="bu">print</span>(<span class="ss">f"Empirical size test beta_1=2 using White SE: </span><span class="sc">{</span>np<span class="sc">.</span>mean(np.<span class="bu">abs</span>(np.array(t_stats_hc)) <span class="op">&gt;</span> <span class="fl">1.965</span>)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb10-61"><a href="#cb10-61"></a><span class="bu">print</span>(<span class="ss">f"Empirical size test beta_1=2 using HAC SE: </span><span class="sc">{</span>np<span class="sc">.</span>mean(np.<span class="bu">abs</span>(np.array(t_stats_hac)) <span class="op">&gt;</span> <span class="fl">1.965</span>)<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Empirical size test beta_1=2 using White SE: 0.255
Empirical size test beta_1=2 using HAC SE: 0.075</code></pre>
</div>
</div>
<p>We can use the bootstrap to obtain the standard errors of <span class="math inline">\(\hat{\beta}_1\)</span>. Unfortunately, with time-dependent data, the bootstrap needs to be modified. Instead of sampling with replacement observations from <span class="math inline">\(y_t\)</span> and <span class="math inline">\(x_t\)</span>, we will sample blocks of length <span class="math inline">\(\ell\)</span> with replacement. By resampling blocks, we ensure that the correlation in the data is preserved.</p>
<p>The moving block bootstrap (MBB) adapts the traditional bootstrap method to handle data where observations are dependent, such as in time series analysis. This approach involves resampling consecutive observation blocks to preserve the data’s internal structure and dependence.</p>
<section id="steps-for-moving-block-bootstrap-mbb" class="level3">
<h3 class="anchored" data-anchor-id="steps-for-moving-block-bootstrap-mbb">Steps for Moving Block Bootstrap (MBB):</h3>
<ol type="1">
<li><p>** Choose Block Length **: Determine the length of the blocks, <span class="math inline">\(\ell\)</span>, that will be resampled. This length should be chosen based on the data’s correlation structure: it should be large enough to capture the dependence within the data.</p></li>
<li><p><strong>Generate Blocks</strong>: From the original dataset of size <span class="math inline">\(T\)</span>, generate new datasets by sampling blocks of length <span class="math inline">\(\ell\)</span> and concatenate them until reaching the size <span class="math inline">\(T\)</span>. Blocks should be sampled with replacement.</p></li>
<li><p><strong>Resample Data within Blocks</strong>: Sample <span class="math inline">\(y_t\)</span> and <span class="math inline">\(x_t\)</span> using the sampled blocks. This is the bootstrapped dataset.</p></li>
<li><p><strong>Refit the Model</strong>: Fit the regression model to each bootstrapped dataset and collect the estimated parameters for each dataset.</p></li>
<li><p><strong>Calculate Statistics</strong>: Calculate the standard deviation of the bootstrap estimate. These are the standard errors.</p></li>
</ol>
<div id="73c0efab" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="im">import</span> statsmodels.api <span class="im">as</span> sm</span>
<span id="cb12-3"><a href="#cb12-3"></a></span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="kw">def</span> moving_block_bootstrap(x, y, block_length, num_bootstrap):</span>
<span id="cb12-5"><a href="#cb12-5"></a>  T <span class="op">=</span> <span class="bu">len</span>(y)  <span class="co"># Total number of observations</span></span>
<span id="cb12-6"><a href="#cb12-6"></a>  num_blocks <span class="op">=</span> T <span class="op">//</span> block_length <span class="op">+</span> (<span class="dv">1</span> <span class="cf">if</span> T <span class="op">%</span> block_length <span class="cf">else</span> <span class="dv">0</span>)</span>
<span id="cb12-7"><a href="#cb12-7"></a></span>
<span id="cb12-8"><a href="#cb12-8"></a>  <span class="co"># Fit the original model</span></span>
<span id="cb12-9"><a href="#cb12-9"></a>  X <span class="op">=</span> sm.add_constant(x)</span>
<span id="cb12-10"><a href="#cb12-10"></a>  original_model <span class="op">=</span> sm.OLS(y, X)</span>
<span id="cb12-11"><a href="#cb12-11"></a>  original_results <span class="op">=</span> original_model.fit()</span>
<span id="cb12-12"><a href="#cb12-12"></a></span>
<span id="cb12-13"><a href="#cb12-13"></a>  bootstrap_estimates <span class="op">=</span> np.zeros((num_bootstrap, <span class="dv">2</span>))  <span class="co"># Storing estimates for beta_0 and beta_1</span></span>
<span id="cb12-14"><a href="#cb12-14"></a></span>
<span id="cb12-15"><a href="#cb12-15"></a>  <span class="co"># Perform the bootstrap</span></span>
<span id="cb12-16"><a href="#cb12-16"></a>  <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(num_bootstrap):</span>
<span id="cb12-17"><a href="#cb12-17"></a>    <span class="co"># Create bootstrap sample</span></span>
<span id="cb12-18"><a href="#cb12-18"></a>    bootstrap_indices <span class="op">=</span> np.random.choice(np.arange(num_blocks) <span class="op">*</span> block_length, size<span class="op">=</span>num_blocks, replace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb12-19"><a href="#cb12-19"></a>    bootstrap_sample_indices <span class="op">=</span> np.hstack([np.arange(index, <span class="bu">min</span>(index <span class="op">+</span> block_length, T)) <span class="cf">for</span> index <span class="kw">in</span> bootstrap_indices])</span>
<span id="cb12-20"><a href="#cb12-20"></a>    bootstrap_sample_indices <span class="op">=</span> bootstrap_sample_indices[:T]  <span class="co"># Ensure the bootstrap sample is the same size as the original data</span></span>
<span id="cb12-21"><a href="#cb12-21"></a></span>
<span id="cb12-22"><a href="#cb12-22"></a>    x_bootstrap <span class="op">=</span> x[bootstrap_sample_indices]</span>
<span id="cb12-23"><a href="#cb12-23"></a>    y_bootstrap <span class="op">=</span> y[bootstrap_sample_indices]</span>
<span id="cb12-24"><a href="#cb12-24"></a></span>
<span id="cb12-25"><a href="#cb12-25"></a>    <span class="co"># Refit the model on bootstrap sample</span></span>
<span id="cb12-26"><a href="#cb12-26"></a>    X_bootstrap <span class="op">=</span> sm.add_constant(x_bootstrap)</span>
<span id="cb12-27"><a href="#cb12-27"></a>    bootstrap_model <span class="op">=</span> sm.OLS(y_bootstrap, X_bootstrap)</span>
<span id="cb12-28"><a href="#cb12-28"></a>    bootstrap_results <span class="op">=</span> bootstrap_model.fit()</span>
<span id="cb12-29"><a href="#cb12-29"></a></span>
<span id="cb12-30"><a href="#cb12-30"></a>    <span class="co"># Store the estimates</span></span>
<span id="cb12-31"><a href="#cb12-31"></a>    bootstrap_estimates[i, :] <span class="op">=</span> bootstrap_results.params</span>
<span id="cb12-32"><a href="#cb12-32"></a>    </span>
<span id="cb12-33"><a href="#cb12-33"></a>    <span class="cf">return</span> bootstrap_estimates</span>
<span id="cb12-34"><a href="#cb12-34"></a></span>
<span id="cb12-35"><a href="#cb12-35"></a><span class="co"># Run moving block bootstrap</span></span>
<span id="cb12-36"><a href="#cb12-36"></a>block_length <span class="op">=</span> <span class="dv">12</span></span>
<span id="cb12-37"><a href="#cb12-37"></a>num_bootstrap <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb12-38"><a href="#cb12-38"></a>x, y, errors <span class="op">=</span> simulate_regression_with_ar1_errors(<span class="dv">200</span>, beta0, beta1, phi_x, phi_u, sigma)</span>
<span id="cb12-39"><a href="#cb12-39"></a>bootstrap_results <span class="op">=</span> moving_block_bootstrap(x, y, block_length, num_bootstrap)</span>
<span id="cb12-40"><a href="#cb12-40"></a></span>
<span id="cb12-41"><a href="#cb12-41"></a><span class="co"># Calculate and print standard errors</span></span>
<span id="cb12-42"><a href="#cb12-42"></a>bootstrap_standard_errors <span class="op">=</span> bootstrap_results.std(axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb12-43"><a href="#cb12-43"></a><span class="bu">print</span>(<span class="st">"Bootstrap Standard Errors:"</span>)</span>
<span id="cb12-44"><a href="#cb12-44"></a><span class="bu">print</span>(<span class="st">"SE(beta_0):"</span>, bootstrap_standard_errors[<span class="dv">0</span>])</span>
<span id="cb12-45"><a href="#cb12-45"></a><span class="bu">print</span>(<span class="st">"SE(beta_1):"</span>, bootstrap_standard_errors[<span class="dv">1</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Bootstrap Standard Errors:
SE(beta_0): 0.026787210831234053
SE(beta_1): 0.05979213797333231</code></pre>
</div>
</div>
</section>
</section>
<section id="assignment-3" class="level2">
<h2 class="anchored" data-anchor-id="assignment-3">Assignment 3</h2>
<section id="task" class="level3">
<h3 class="anchored" data-anchor-id="task">Task</h3>
<p>Apply Monte Carlo simulations combined with bootstrap methods to evaluate the quality of inference on <span class="math inline">\(\beta_1\)</span>​ using serially correlated data.</p>
<section id="steps" class="level4">
<h4 class="anchored" data-anchor-id="steps">Steps</h4>
<ol type="1">
<li><p>Simulate data according to <code>simulate_regression_with_ar1_errors</code>.</p></li>
<li><p>Calculate bootstrap standard errors.</p></li>
<li><p>Construct a 95% confidence interval for <span class="math inline">\(\beta_1\)</span>​ using both the bootstrap and the theoretical standard errors.</p></li>
<li><p>Perform Monte Carlo simulations for <span class="math inline">\(T=100\)</span> and <span class="math inline">\(T=500\)</span>, and assess the empirical coverage of the confidence intervals.</p></li>
</ol>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/gragusa\.org\/comptools\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>